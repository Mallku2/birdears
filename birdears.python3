#!/usr/bin/env python3

import subprocess
import time
from random import randrange

from pprint import pprint

class QuestionBase:
    # maybe we'd better use circle of fifths here
    notes = ['C', 'C#', 'D', 'Eb', 'E', 'F', 'F#', 'G', 'Ab', 'A', 'Bb', 'B']

    major = {'A': ['A', 'B', 'C#', 'D', 'E', 'F#', 'G#', 'A'],
     'Ab': ['Ab', 'Bb', 'C', 'Db', 'Eb', 'F', 'G', 'Ab'],
     'B': ['B', 'C#', 'D#', 'E', 'F#', 'G#', 'A#', 'B'],
     'Bb': ['Bb', 'C', 'D', 'Eb', 'F', 'G', 'A', 'Bb'],
     'C': ['C', 'D', 'E', 'F', 'G', 'A', 'B', 'C'],
     'C#': ['C#', 'D#', 'E#', 'F#', 'G#', 'A#', 'B#', 'C#'],
     'D': ['D', 'E', 'F#', 'G', 'A', 'B', 'C#', 'D'],
     'E': ['E', 'F#', 'G#', 'A', 'B', 'C#', 'D#', 'E'],
     'Eb': ['Eb', 'F', 'G', 'Ab', 'Bb', 'C', 'D', 'Eb'],
     'F': ['F', 'G', 'A', 'Bb', 'C', 'D', 'E', 'F'],
     'F#': ['F#', 'G#', 'A#', 'B', 'C#', 'D#', 'E#', 'F#'],
     'G': ['G', 'A', 'B', 'C', 'D', 'E', 'F#', 'G']}

    minor = {'A': ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'A'],
     'Ab': ['Ab', 'Bb', 'Cb', 'Db', 'Eb', 'Fb', 'Gb', 'Ab'],
     'B': ['B', 'C#', 'D', 'E', 'F#', 'G', 'A', 'B'],
     'Bb': ['Bb', 'C', 'Db', 'Eb', 'F', 'Gb', 'Ab', 'Bb'],
     'C': ['C', 'D', 'Eb', 'F', 'G', 'Ab', 'Bb', 'C'],
     'C#': ['C#', 'D#', 'E', 'F#', 'G#', 'A', 'B', 'C#'],
     'D': ['D', 'E', 'F', 'G', 'A', 'Bb', 'C', 'D'],
     'E': ['E', 'F#', 'G', 'A', 'B', 'C', 'D', 'E'],
     'Eb': ['Eb', 'F', 'Gb', 'Ab', 'Bb', 'Cb', 'Db', 'Eb'],
     'F': ['F', 'G', 'Ab', 'Bb', 'C', 'Db', 'Eb', 'F'],
     'F#': ['F#', 'G#', 'A', 'B', 'C#', 'D', 'E', 'F#'],
     'G': ['G', 'A', 'Bb', 'C', 'D', 'Eb', 'F', 'G']}

    chromatic = {'A': ['A', 'Bb', 'B', 'C', 'C#', 'D', 'Eb', 'E', 'F', 'F#', 'G', 'Ab', 'A'],
     'Ab': ['Ab', 'A', 'Bb', 'B', 'C', 'C#', 'D', 'Eb', 'E', 'F', 'F#', 'G', 'Ab'],
     'B': ['B', 'C', 'C#', 'D', 'Eb', 'E', 'F', 'F#', 'G', 'Ab', 'A', 'Bb', 'B'],
     'Bb': ['Bb', 'B', 'C', 'C#', 'D', 'Eb', 'E', 'F', 'F#', 'G', 'Ab', 'A', 'Bb'],
     'C': ['C', 'C#', 'D', 'Eb', 'E', 'F', 'F#', 'G', 'Ab', 'A', 'Bb', 'B', 'C'],
     'C#': ['C#', 'D', 'Eb', 'E', 'F', 'F#', 'G', 'Ab', 'A', 'Bb', 'B', 'C', 'C#'],
     'D': ['D', 'Eb', 'E', 'F', 'F#', 'G', 'Ab', 'A', 'Bb', 'B', 'C', 'C#', 'D'],
     'E': ['E', 'F', 'F#', 'G', 'Ab', 'A', 'Bb', 'B', 'C', 'C#', 'D', 'Eb', 'E'],
     'Eb': ['Eb', 'E', 'F', 'F#', 'G', 'Ab', 'A', 'Bb', 'B', 'C', 'C#', 'D', 'Eb'],
     'F': ['F', 'F#', 'G', 'Ab', 'A', 'Bb', 'B', 'C', 'C#', 'D', 'Eb', 'E', 'F'],
     'F#': ['F#', 'G', 'Ab', 'A', 'Bb', 'B', 'C', 'C#', 'D', 'Eb', 'E', 'F', 'F#'],
     'G': ['G', 'Ab', 'A', 'Bb', 'B', 'C', 'C#', 'D', 'Eb', 'E', 'F', 'F#', 'G']}

    intervals = {0: [0, 'P1', 'Perfect Unison'],
     1: [1, 'm2', 'Minor Second'],
     2: [2, 'M2', 'Major Second'],
     3: [3, 'm3', 'Minor Third'],
     4: [4, 'M3', 'Major Third'],
     5: [5, 'P4', 'Perfect Fourth'],
     6: [6, 'A4', 'Augmented Fourth'],
     7: [7, 'P5', 'Perfect Fifth'],
     8: [8, 'm6', 'Minor Sixth'],
     9: [9, 'M6', 'Major Sixth'],
     10: [10, 'm7', 'Minor Seventh'],
     11: [11, 'M7', 'Major Seventh'],
     12: [12, 'P8', 'Perfect Octave']}

    major_ints = [0,2,4,5,7,9,11,12]
    minor_ints = [0,2,3,5,7,8,10,12]
    
    enharmonics = {
        'C#' : 'Db',
        'D#' : 'Eb',
        'E#' : 'F',
        'F#' : 'Gb',
        'G#' : 'Ab',
        'A#' : 'Bb',
        'B#' : 'C',
        'Cb' : 'B',
        'Db' : 'C#',
        'Eb' : 'D#',
        'Fb' : 'E',
        'Gb' : 'F#',
        'Ab' : 'G#',
        'Bb' : 'A#',
        }

    def __init__(self):
        pass

    def get_semitones(self, note_name, chromatic):
        
        semitones = False

        if note_name in self.enharmonics:
            enharmonic = self.enharmonics[note_name]

        if note_name in chromatic:
            semitones = chromatic.index(note_name)
        elif enharmonic in chromatic:
            semitones = chromatic.index(enharmonic)

        return semitones

# http://code.activestate.com/recipes/134892/
class _Getch:
    """Gets a single character from standard input.  Does not echo to the
screen."""
    def __init__(self):
        try:
            self.impl = _GetchWindows()
        except ImportError:
            self.impl = _GetchUnix()

    def __call__(self): return self.impl()
class _GetchUnix:
    def __init__(self):
        import tty, sys

    def __call__(self):
        import sys, tty, termios
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        try:
            tty.setraw(sys.stdin.fileno())
            ch = sys.stdin.read(1)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        return ch
class _GetchWindows:
    def __init__(self):
        import msvcrt

    def __call__(self):
        import msvcrt
        return msvcrt.getch()

def wait(seconds):
    time.sleep(seconds)


def play_note(note='C', duration=4, delay=0):
    # requires sox to be installed
    command = (
        "play -qn synth {duration} pluck {note}"
        " fade l 0 {duration} 2 reverb"
    ).format(note=note, duration=duration)

    subprocess.Popen(command.split())

    if delay:
        wait(delay)

class Question(QuestionBase):
    def __init__(self, kind='major', octave=[2,6]):
        super(Question, self).__init__() # runs base class init

        self.tonic = tonic = self.notes[randrange(len(self.notes))]

        self.scale = scale = getattr(self, kind)[tonic]

        self.tone_chroma = self.chromatic[tonic]

        if type(octave) == int:
            self.octave = octave
        elif type(octave) == list and len(octave) == 2:
            self.octave = randrange(octave[0], octave[1])

        self.upper_octave = upper_octave = self.octave+1

        self.scale_size = scale_size = len(scale)
        self.tonic = tonic = scale[0]
        
        self.concrete_scale = ["{}{}".format(tone,self.octave) for tone in self.scale[:-1]]
        self.concrete_scale.append("{}{}".format(tonic,upper_octave))
        
        self.ival_idx = randrange(scale_size)
        self.ival_note_concrete = self.concrete_scale[self.ival_idx]
        self.ival_note_name = self.scale[self.ival_idx]
        self.ival_semitones = self.get_semitones(self.ival_note_name, self.tone_chroma)

    def play_question():
        pass

    def play_resolution():
        pass

    def check_question():
        pass

getch = _Getch()

while True:
    #question = get_question(scale,octave, chromatic[tonic])
    question = Question()

    pprint([question.scale,question.ival_note_name,question.ival_semitones])
    user_input = getch()

    keyidx = "zxcvbnm" # semitones on chromatic dont have keyboard keys for them

    if user_input == 'q':
        exit(0)
    #elif keyidx.index(user_input) == question['question_interval']['idx']:
    #    print('EUREKA!!!!!!!')

