#!/usr/bin/env python3

import subprocess
import time
from random import randrange

from pprint import pprint

class QuestionBase:
    # maybe we'd better use circle of fifths here
    notes = ['C', 'C#', 'D', 'Eb', 'E', 'F', 'F#', 'G', 'Ab', 'A', 'Bb', 'B']

    major = {'A': ['A', 'B', 'C#', 'D', 'E', 'F#', 'G#', 'A'],
     'Ab': ['Ab', 'Bb', 'C', 'Db', 'Eb', 'F', 'G', 'Ab'],
     'B': ['B', 'C#', 'D#', 'E', 'F#', 'G#', 'A#', 'B'],
     'Bb': ['Bb', 'C', 'D', 'Eb', 'F', 'G', 'A', 'Bb'],
     'C': ['C', 'D', 'E', 'F', 'G', 'A', 'B', 'C'],
     'C#': ['C#', 'D#', 'E#', 'F#', 'G#', 'A#', 'B#', 'C#'],
     'D': ['D', 'E', 'F#', 'G', 'A', 'B', 'C#', 'D'],
     'E': ['E', 'F#', 'G#', 'A', 'B', 'C#', 'D#', 'E'],
     'Eb': ['Eb', 'F', 'G', 'Ab', 'Bb', 'C', 'D', 'Eb'],
     'F': ['F', 'G', 'A', 'Bb', 'C', 'D', 'E', 'F'],
     'F#': ['F#', 'G#', 'A#', 'B', 'C#', 'D#', 'E#', 'F#'],
     'G': ['G', 'A', 'B', 'C', 'D', 'E', 'F#', 'G']}

    minor = {'A': ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'A'],
     'Ab': ['Ab', 'Bb', 'Cb', 'Db', 'Eb', 'Fb', 'Gb', 'Ab'],
     'B': ['B', 'C#', 'D', 'E', 'F#', 'G', 'A', 'B'],
     'Bb': ['Bb', 'C', 'Db', 'Eb', 'F', 'Gb', 'Ab', 'Bb'],
     'C': ['C', 'D', 'Eb', 'F', 'G', 'Ab', 'Bb', 'C'],
     'C#': ['C#', 'D#', 'E', 'F#', 'G#', 'A', 'B', 'C#'],
     'D': ['D', 'E', 'F', 'G', 'A', 'Bb', 'C', 'D'],
     'E': ['E', 'F#', 'G', 'A', 'B', 'C', 'D', 'E'],
     'Eb': ['Eb', 'F', 'Gb', 'Ab', 'Bb', 'Cb', 'Db', 'Eb'],
     'F': ['F', 'G', 'Ab', 'Bb', 'C', 'Db', 'Eb', 'F'],
     'F#': ['F#', 'G#', 'A', 'B', 'C#', 'D', 'E', 'F#'],
     'G': ['G', 'A', 'Bb', 'C', 'D', 'Eb', 'F', 'G']}

    chromatic = {'A': ['A', 'Bb', 'B', 'C', 'C#', 'D', 'Eb', 'E', 'F', 'F#', 'G', 'Ab', 'A'],
     'Ab': ['Ab', 'A', 'Bb', 'B', 'C', 'C#', 'D', 'Eb', 'E', 'F', 'F#', 'G', 'Ab'],
     'B': ['B', 'C', 'C#', 'D', 'Eb', 'E', 'F', 'F#', 'G', 'Ab', 'A', 'Bb', 'B'],
     'Bb': ['Bb', 'B', 'C', 'C#', 'D', 'Eb', 'E', 'F', 'F#', 'G', 'Ab', 'A', 'Bb'],
     'C': ['C', 'C#', 'D', 'Eb', 'E', 'F', 'F#', 'G', 'Ab', 'A', 'Bb', 'B', 'C'],
     'C#': ['C#', 'D', 'Eb', 'E', 'F', 'F#', 'G', 'Ab', 'A', 'Bb', 'B', 'C', 'C#'],
     'D': ['D', 'Eb', 'E', 'F', 'F#', 'G', 'Ab', 'A', 'Bb', 'B', 'C', 'C#', 'D'],
     'E': ['E', 'F', 'F#', 'G', 'Ab', 'A', 'Bb', 'B', 'C', 'C#', 'D', 'Eb', 'E'],
     'Eb': ['Eb', 'E', 'F', 'F#', 'G', 'Ab', 'A', 'Bb', 'B', 'C', 'C#', 'D', 'Eb'],
     'F': ['F', 'F#', 'G', 'Ab', 'A', 'Bb', 'B', 'C', 'C#', 'D', 'Eb', 'E', 'F'],
     'F#': ['F#', 'G', 'Ab', 'A', 'Bb', 'B', 'C', 'C#', 'D', 'Eb', 'E', 'F', 'F#'],
     'G': ['G', 'Ab', 'A', 'Bb', 'B', 'C', 'C#', 'D', 'Eb', 'E', 'F', 'F#', 'G']}

    intervals = {0: [0, 'P1', 'Perfect Unison'],
     1: [1, 'm2', 'Minor Second'],
     2: [2, 'M2', 'Major Second'],
     3: [3, 'm3', 'Minor Third'],
     4: [4, 'M3', 'Major Third'],
     5: [5, 'P4', 'Perfect Fourth'],
     6: [6, 'A4', 'Augmented Fourth'],
     7: [7, 'P5', 'Perfect Fifth'],
     8: [8, 'm6', 'Minor Sixth'],
     9: [9, 'M6', 'Major Sixth'],
     10: [10, 'm7', 'Minor Seventh'],
     11: [11, 'M7', 'Major Seventh'],
     12: [12, 'P8', 'Perfect Octave']}

    major_ints = [0,2,4,5,7,9,11,12]
    minor_ints = [0,2,3,5,7,8,10,12]
    
    enharmonics = {
        'C#' : 'Db',
        'D#' : 'Eb',
        'E#' : 'F',
        'F#' : 'Gb',
        'G#' : 'Ab',
        'A#' : 'Bb',
        'B#' : 'C',
        'Cb' : 'B',
        'Db' : 'C#',
        'Eb' : 'D#',
        'Fb' : 'E',
        'Gb' : 'F#',
        'Ab' : 'G#',
        'Bb' : 'A#',
        }

    def __init__(self):
        pass

    def get_semitones(self, note_name, chromatic, tonic_octave, note_concrete):

        semitones = False

        chroma = []
        current_octave = tonic_octave
        for idx,tone in enumerate(chromatic):
            if tone == 'C' and idx>0:
                current_octave+=1
            chroma.append("{}{}".format(tone, current_octave))

        if note_concrete in chroma:
            semitones = chroma.index(note_concrete)

        elif len(note_concrete) == 3:
            note_name = note_concrete[:2]
            note_octave = note_concrete[2:3]

            if note_name in self.enharmonics:
                note = "{}{}".format(self.enharmonics[note_name], note_octave)
                semitones = chroma.index(note)

        return semitones

# http://code.activestate.com/recipes/134892/
class _Getch:
    """Gets a single character from standard input.  Does not echo to the
screen."""
    def __init__(self):
        try:
            self.impl = _GetchWindows()
        except ImportError:
            self.impl = _GetchUnix()

    def __call__(self): return self.impl()
class _GetchUnix:
    def __init__(self):
        import tty, sys

    def __call__(self):
        import sys, tty, termios
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        try:
            tty.setraw(sys.stdin.fileno())
            ch = sys.stdin.read(1)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        return ch
class _GetchWindows:
    def __init__(self):
        import msvcrt

    def __call__(self):
        import msvcrt
        return msvcrt.getch()

def wait(seconds):
    time.sleep(seconds)


def play_note(note='C', duration=4, delay=0):
    # requires sox to be installed
    command = (
        "play -qn synth {duration} pluck {note}"
        " fade l 0 {duration} 2 reverb"
    ).format(note=note, duration=duration)

    subprocess.Popen(command.split())

    if delay:
        wait(delay)

class Question(QuestionBase):
    def __init__(self, kind='major', octave=[2,6]):
        super(Question, self).__init__() # runs base class init

        self.tonic = tonic = self.notes[randrange(len(self.notes))]

        self.scale = scale = getattr(self, kind)[tonic]

        self.tone_chroma = self.chromatic[tonic]

        if type(octave) == int:
            self.octave = octave
        elif type(octave) == list and len(octave) == 2:
            self.octave = randrange(octave[0], octave[1])

        self.upper_octave = upper_octave = self.octave+1

        self.scale_size = scale_size = len(scale)
        self.tonic = tonic = scale[0]
        
        self.concrete_scale = []
        current_octave = self.octave
        for idx,tone in enumerate(self.scale):
            if 'C' in tone and idx>0:
                current_octave+=1

            self.concrete_scale.append("{}{}".format(tone, current_octave))
        
        self.chroma_concrete = []
        current_octave = self.octave
        for idx,tone in enumerate(self.tone_chroma):
            if tone == 'C' and idx>0:
                current_octave+=1

            self.chroma_concrete.append("{}{}".format(tone, current_octave))

        self.concrete_tonic = self.concrete_scale[0]
        
        self.ival_idx = randrange(scale_size)
        self.ival_note_concrete = self.concrete_scale[self.ival_idx]
        self.ival_note_name = self.scale[self.ival_idx]
        #self.ival_semitones = self.get_semitones(self.ival_note_name, self.tone_chroma)
        self.ival_semitones = self.get_semitones(self.ival_note_name, self.tone_chroma, self.octave, self.ival_note_concrete)

        self.resolution_concrete = []
        if self.ival_semitones <= 6:
            self.resolution_concrete = self.concrete_scale[:self.ival_idx+1] #hotfix
            self.resolution_concrete.reverse() 
        else:
            self.resolution_concrete = self.concrete_scale[self.ival_idx:]

    def play_question(self):
        self.question_duration = 2
        self.question_delay = 1.5

        tonic = self.concrete_tonic
        interval = self.ival_note_concrete

        play_note(note=tonic, duration=self.question_duration, delay=self.question_delay)
        #play_note(note=interval, duration=self.question_duration, delay=self.question_delay)
        play_note(note=interval, duration=self.question_duration, delay=0)

    def play_resolution(self):
        self.resolution_duration = 2.5
        self.resolution_delay = 0.5

        tonic = self.concrete_tonic
        interval = self.ival_note_concrete

        for tone in self.resolution_concrete:
            play_note(note=tone, duration=self.resolution_duration, delay=self.resolution_delay)

    def check_question(self, semitones):
        if semitones == self.ival_semitones:
            return True
        else:
            return False

getch = _Getch()

# keyindex for chromatic major context

keyidx = "zsxdcvgbhnjmZ" # semitones on chromatic dont have keyboard keys for them

while True:
    #question = get_question(scale,octave, chromatic[tonic])
    question = Question()

    pprint([question.concrete_scale, question.ival_note_name, question.ival_semitones, question.resolution_concrete, question.chroma_concrete])
    question.play_question()

    user_input = getch()

    if user_input == 'q':
        exit(0)

    if question.check_question(keyidx.index(user_input)):
        print("Correct!")
    else:
        print("Incorrect")

    question.play_resolution()
    
    
    #    print('EUREKA!!!!!!!')

