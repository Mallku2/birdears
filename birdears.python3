#!/usr/bin/env python3

import subprocess
import time
from random import randrange

from pprint import pprint

class QuestionBase:
    # maybe we'd better use circle of fifths here
    notes = ['C', 'C#', 'D', 'Eb', 'E', 'F', 'F#', 'G', 'Ab', 'A', 'Bb', 'B']

    major = {'A': ['A', 'B', 'C#', 'D', 'E', 'F#', 'G#', 'A'],
     'Ab': ['Ab', 'Bb', 'C', 'Db', 'Eb', 'F', 'G', 'Ab'],
     'B': ['B', 'C#', 'D#', 'E', 'F#', 'G#', 'A#', 'B'],
     'Bb': ['Bb', 'C', 'D', 'Eb', 'F', 'G', 'A', 'Bb'],
     'C': ['C', 'D', 'E', 'F', 'G', 'A', 'B', 'C'],
     'C#': ['C#', 'D#', 'E#', 'F#', 'G#', 'A#', 'B#', 'C#'],
     'D': ['D', 'E', 'F#', 'G', 'A', 'B', 'C#', 'D'],
     'E': ['E', 'F#', 'G#', 'A', 'B', 'C#', 'D#', 'E'],
     'Eb': ['Eb', 'F', 'G', 'Ab', 'Bb', 'C', 'D', 'Eb'],
     'F': ['F', 'G', 'A', 'Bb', 'C', 'D', 'E', 'F'],
     'F#': ['F#', 'G#', 'A#', 'B', 'C#', 'D#', 'E#', 'F#'],
     'G': ['G', 'A', 'B', 'C', 'D', 'E', 'F#', 'G']}

    minor = {'A': ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'A'],
     'Ab': ['Ab', 'Bb', 'Cb', 'Db', 'Eb', 'Fb', 'Gb', 'Ab'],
     'B': ['B', 'C#', 'D', 'E', 'F#', 'G', 'A', 'B'],
     'Bb': ['Bb', 'C', 'Db', 'Eb', 'F', 'Gb', 'Ab', 'Bb'],
     'C': ['C', 'D', 'Eb', 'F', 'G', 'Ab', 'Bb', 'C'],
     'C#': ['C#', 'D#', 'E', 'F#', 'G#', 'A', 'B', 'C#'],
     'D': ['D', 'E', 'F', 'G', 'A', 'Bb', 'C', 'D'],
     'E': ['E', 'F#', 'G', 'A', 'B', 'C', 'D', 'E'],
     'Eb': ['Eb', 'F', 'Gb', 'Ab', 'Bb', 'Cb', 'Db', 'Eb'],
     'F': ['F', 'G', 'Ab', 'Bb', 'C', 'Db', 'Eb', 'F'],
     'F#': ['F#', 'G#', 'A', 'B', 'C#', 'D', 'E', 'F#'],
     'G': ['G', 'A', 'Bb', 'C', 'D', 'Eb', 'F', 'G']}

    chromatic = {'A': ['A', 'Bb', 'B', 'C', 'C#', 'D', 'Eb', 'E', 'F', 'F#', 'G', 'Ab', 'A'],
     'Ab': ['Ab', 'A', 'Bb', 'B', 'C', 'C#', 'D', 'Eb', 'E', 'F', 'F#', 'G', 'Ab'],
     'B': ['B', 'C', 'C#', 'D', 'Eb', 'E', 'F', 'F#', 'G', 'Ab', 'A', 'Bb', 'B'],
     'Bb': ['Bb', 'B', 'C', 'C#', 'D', 'Eb', 'E', 'F', 'F#', 'G', 'Ab', 'A', 'Bb'],
     'C': ['C', 'C#', 'D', 'Eb', 'E', 'F', 'F#', 'G', 'Ab', 'A', 'Bb', 'B', 'C'],
     'C#': ['C#', 'D', 'Eb', 'E', 'F', 'F#', 'G', 'Ab', 'A', 'Bb', 'B', 'C', 'C#'],
     'D': ['D', 'Eb', 'E', 'F', 'F#', 'G', 'Ab', 'A', 'Bb', 'B', 'C', 'C#', 'D'],
     'E': ['E', 'F', 'F#', 'G', 'Ab', 'A', 'Bb', 'B', 'C', 'C#', 'D', 'Eb', 'E'],
     'Eb': ['Eb', 'E', 'F', 'F#', 'G', 'Ab', 'A', 'Bb', 'B', 'C', 'C#', 'D', 'Eb'],
     'F': ['F', 'F#', 'G', 'Ab', 'A', 'Bb', 'B', 'C', 'C#', 'D', 'Eb', 'E', 'F'],
     'F#': ['F#', 'G', 'Ab', 'A', 'Bb', 'B', 'C', 'C#', 'D', 'Eb', 'E', 'F', 'F#'],
     'G': ['G', 'Ab', 'A', 'Bb', 'B', 'C', 'C#', 'D', 'Eb', 'E', 'F', 'F#', 'G']}

    intervals = {0: [0, 'P1', 'Perfect Unison'],
     1: [1, 'm2', 'Minor Second'],
     2: [2, 'M2', 'Major Second'],
     3: [3, 'm3', 'Minor Third'],
     4: [4, 'M3', 'Major Third'],
     5: [5, 'P4', 'Perfect Fourth'],
     6: [6, 'A4', 'Augmented Fourth'],
     7: [7, 'P5', 'Perfect Fifth'],
     8: [8, 'm6', 'Minor Sixth'],
     9: [9, 'M6', 'Major Sixth'],
     10: [10, 'm7', 'Minor Seventh'],
     11: [11, 'M7', 'Major Seventh'],
     12: [12, 'P8', 'Perfect Octave']}

    major_ints = [0,2,4,5,7,9,11,12]
    minor_ints = [0,2,3,5,7,8,10,12]
    
    enharmonics = {
        'C#' : 'Db',
        'D#' : 'Eb',
        'E#' : 'F',
        'F#' : 'Gb',
        'G#' : 'Ab',
        'A#' : 'Bb',
        'B#' : 'C',
        'Cb' : 'B',
        'Db' : 'C#',
        'Eb' : 'D#',
        'Fb' : 'E',
        'Gb' : 'F#',
        'Ab' : 'G#',
        'Bb' : 'A#',
        }

    keyboard_indices = {
            'diatonic': {
                'minor' : 'z xc v bn m Z XC V BN M',
                'major' : 'z x cv b n mZ X CV B NM'
            },
            'chromatic': {
                'minor' : "zsxcfvgbnjmkZSXCFVGBNJMK",
                'major' : "zsxdcvgbhnjmZSXDCVGBHNJM",
            }
    }

    def __init__(self):

        self.question_duration = 2
        self.question_delay = 1.5
        self.question_pos_delay = 0

        self.resolution_duration = 2.5
        self.resolution_delay = 0.5
        self.resolution_pos_delay = 1

        # keyindex for major and chromatic major context
        #keyidx_maj = "zsxdcvgbhnjmZSXDCVGBHN" # semitones (e-f, b-c) on chromatic dont have keyboard keys for them

        #  s d   g h j        IIb  IIIb       Vb VIb  VIIb 
        # z x c v b n m  <-  I   II   III  IV   V   VI   VII
        #
        #  -- SHIFT meaning an octave higher

        # keyindex for minor and chromatic minor context

        #  s   f g   j         a   db eb  gb
        # z x c v b n m  ---- a b c  d e f  g
        #keyidx_min = "zsxcfvgbnjmZSXCFVBNJM" 

    def get_semitones(self, note_name, chromatic, tonic_octave, note_concrete):

        semitones = False

        chroma = []
        current_octave = tonic_octave
        for idx,tone in enumerate(chromatic):
            if tone == 'C' and idx>0:
                current_octave+=1
            chroma.append("{}{}".format(tone, current_octave))

        if note_concrete in chroma:
            semitones = chroma.index(note_concrete)

        elif len(note_concrete) == 3:
            note_name = note_concrete[:2]
            note_octave = note_concrete[2:3]

            if note_name in self.enharmonics:
                note = "{}{}".format(self.enharmonics[note_name], note_octave)
                semitones = chroma.index(note)

        return semitones

    def wait(self, seconds):
        time.sleep(seconds)

    def play_note(self, note='C', duration=4, delay=0):
        # requires sox to be installed
        command = (
            "play -qn synth {duration} pluck {note}"
            " fade l 0 {duration} 2 reverb"
        ).format(note=note, duration=duration)

        subprocess.Popen(command.split())

        if delay:
            self.wait(delay)

    def play_question(self):

        tonic = self.concrete_tonic
        interval = self.ival_note_concrete

        play_note = self.play_note

        play_note(note=tonic, duration=self.question_duration, delay=self.question_delay)
        play_note(note=interval, duration=self.question_duration, delay=0)

        if self.question_pos_delay:
            self.wait(self.resolution_pos_delay)

    def play_resolution(self):

        play_note = self.play_note

        for tone in self.resolution_concrete:
            play_note(note=tone, duration=self.resolution_duration, delay=self.resolution_delay)

        if self.resolution_pos_delay:
            self.wait(self.resolution_pos_delay)

    #def check_question(self, semitones):
    def check_question(self, user_input_char):


        semitones = self.keyboard_index.index(user_input_char)

        if semitones == self.ival_semitones:
            return True
        else:
            return False

    def make_interval(self):

        
        if self.mode == 'diatonic':
            self.ival_idx = randrange(self.scale_size)

            self.ival_note_concrete = self.concrete_scale[self.ival_idx]
            self.ival_note_name = self.scale[self.ival_idx]

        elif self.mode == 'chromatic':
            self.ival_idx = randrange(len(self.tone_chroma))

            self.ival_note_concrete = self.chroma_concrete[self.ival_idx]
            self.ival_note_name = self.tone_chroma[self.ival_idx]

        self.ival_semitones = self.get_semitones(self.ival_note_name, self.tone_chroma, self.octave, self.ival_note_concrete)

    def make_resolution(self):

        self.resolution_concrete = []
        if self.ival_semitones <= 6:
            self.resolution_concrete = self.concrete_scale[:self.ival_idx+1] #hotfix
            self.resolution_concrete.reverse() 
        else:
            self.resolution_concrete = self.concrete_scale[self.ival_idx:]


    def make_concrete_scale(self):

        self.concrete_scale = []
        current_octave = self.octave
        for idx,tone in enumerate(self.scale):
            if 'C' in tone and idx>0:
                current_octave+=1

            self.concrete_scale.append("{}{}".format(tone, current_octave))

    def make_concrete_chroma(self):

        self.chroma_concrete = []
        current_octave = self.octave
        for idx,tone in enumerate(self.tone_chroma):
            if tone == 'C' and idx>0:
                current_octave+=1

            self.chroma_concrete.append("{}{}".format(tone, current_octave))

class Question(QuestionBase):

    def __init__(self, kind='major', mode='diatonic', octave=[2,6]):
    
        super(Question, self).__init__() # runs base class init

        self.kind = kind
        self.mode = mode

        if type(octave) == int:
            self.octave = octave
        elif type(octave) == list and len(octave) == 2:
            self.octave = randrange(octave[0], octave[1])

        self.keyboard_index = self.keyboard_indices[self.mode][self.kind]

        self.tonic = tonic = self.notes[randrange(len(self.notes))]

        self.scale = scale = getattr(self, kind)[tonic]
        self.scale_size = scale_size = len(scale)

        self.tone_chroma = self.chromatic[tonic]

        self.make_concrete_scale()
        
        self.make_concrete_chroma()
        self.concrete_tonic = self.concrete_scale[0]
        
        self.make_interval()

        self.make_resolution()

# http://code.activestate.com/recipes/134892/
class _Getch:
    """Gets a single character from standard input.  Does not echo to the
screen."""
    def __init__(self):
        try:
            self.impl = _GetchWindows()
        except ImportError:
            self.impl = _GetchUnix()

    def __call__(self): return self.impl()
class _GetchUnix:
    def __init__(self):
        import tty, sys

    def __call__(self):
        import sys, tty, termios
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        try:
            tty.setraw(sys.stdin.fileno())
            ch = sys.stdin.read(1)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        return ch
class _GetchWindows:
    def __init__(self):
        import msvcrt

    def __call__(self):
        import msvcrt
        return msvcrt.getch()

if __name__ == "__main__":
    getch = _Getch()

    # keyindex for major and chromatic major context
    keyidx_maj = "zsxdcvgbhnjmZSXDCVGBHN" # semitones (e-f, b-c) on chromatic dont have keyboard keys for them

    #  s d   g h j        IIb  IIIb       Vb VIb  VIIb 
    # z x c v b n m  <-  I   II   III  IV   V   VI   VII
    #
    #  -- SHIFT meaning an octave higher

    # keyindex for minor and chromatic minor context

    #  s   f g   j         a   db eb  gb
    # z x c v b n m  ---- a b c  d e f  g
    keyidx_min = "zsxcfvgbnjmZSXCFVBNJM" 

    while True:
        question = Question(kind='minor')

        padd="─"*20; # vim: insert mode, ^vu2500
        print("""
{}

Tonic: {}, Conc. Scale: {},
Note(Int): {} Int Semitones: {}, Interval: {},
Resolution: {}
Chrom. Conc. Scale: {}

""".format(
            padd,
            question.tonic,
            question.concrete_scale,
            question.ival_note_name,
            question.ival_semitones,
            question.intervals[question.ival_semitones],
            question.resolution_concrete,
            question.chroma_concrete
        ))
        question.play_question()

        user_input = getch()

        if user_input == 'q':
            exit(0)

        if user_input in question.keyboard_index: 
            #if question.check_question(keyidx_min.index(user_input)):
            if question.check_question(user_input):
                print("Correct!")
            else:
                print("Incorrect")

        question.play_resolution()
        
