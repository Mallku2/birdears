<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>birdears &#8212; BirdEars 0.1.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/hljs_styles/monokai.css" type="text/css" />
  <script type="text/javascript" src="../_static/js/highlight.pack.js"></script>
  <script>
  $(document).ready(function() {
  $('div.viewcode-block,pre').each(function(i, block) {
    hljs.highlightBlock(block);
  });
});
</script>
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for birdears</h1><div class="highlight"><pre>
<span></span>#!/usr/bin/env python3

&quot;&quot;&quot;
BirdEars provides facilities to development of musical ear training
exercises.
&quot;&quot;&quot;

import subprocess
import time
from random import randrange, choice
from collections import deque
# from math import floor

DEBUG = True

# FIXME
notes2 = (&#39;C&#39;, &#39;C#&#39;, &#39;D&#39;, &#39;D#&#39;, &#39;E&#39;, &#39;F&#39;, &#39;F#&#39;, &#39;G&#39;, &#39;G#&#39;, &#39;A&#39;, &#39;A#&#39;, &#39;B&#39;)
notes3 = (&#39;C&#39;, &#39;Db&#39;, &#39;D&#39;, &#39;Eb&#39;, &#39;E&#39;, &#39;F&#39;, &#39;Gb&#39;, &#39;G&#39;, &#39;Ab&#39;, &#39;A&#39;, &#39;Bb&#39;, &#39;B&#39;)

KEYS = (&#39;C&#39;, &#39;C#&#39;, &#39;Db&#39;, &#39;D&#39;, &#39;D#&#39;, &#39;Eb&#39;, &#39;E&#39;, &#39;F&#39;, &#39;F#&#39;, &#39;Gb&#39;, &#39;G&#39;, &#39;G#&#39;,
        &#39;Ab&#39;, &#39;A&#39;, &#39;A#&#39;, &#39;Bb&#39;, &#39;B&#39;)

INTERVALS = (
    (0, &#39;P1&#39;, &#39;Perfect Unison&#39;),
    (1, &#39;m2&#39;, &#39;Minor Second&#39;),
    (2, &#39;M2&#39;, &#39;Major Second&#39;),
    (3, &#39;m3&#39;, &#39;Minor Third&#39;),
    (4, &#39;M3&#39;, &#39;Major Third&#39;),
    (5, &#39;P4&#39;, &#39;Perfect Fourth&#39;),
    (6, &#39;A4&#39;, &#39;Augmented Fourth&#39;),
    (7, &#39;P5&#39;, &#39;Perfect Fifth&#39;),
    (8, &#39;m6&#39;, &#39;Minor Sixth&#39;),
    (9, &#39;M6&#39;, &#39;Major Sixth&#39;),
    (10, &#39;m7&#39;, &#39;Minor Seventh&#39;),
    (11, &#39;M7&#39;, &#39;Major Seventh&#39;),
    (12, &#39;P8&#39;, &#39;Perfect Octave&#39;),
    (13, &#39;A8&#39;, &#39;Minor Ninth&#39;),
    (14, &#39;M9&#39;, &#39;Major Ninth&#39;),
    (15, &#39;m10&#39;, &#39;Minor Tenth&#39;),
    (16, &#39;M10&#39;, &#39;Major Tenth&#39;),
    (17, &#39;P11&#39;, &#39;Perfect Eleventh&#39;),
    (18, &#39;A11&#39;, &#39;Augmented Eleventh&#39;),
    (19, &#39;P12&#39;, &#39;Perfect Twelfth&#39;),
    (20, &#39;m13&#39;, &#39;Minor Thirteenth&#39;),
    (21, &#39;M13&#39;, &#39;Major Thirteenth&#39;),
    (22, &#39;m14&#39;, &#39;Minor Fourteenth&#39;),
    (23, &#39;M14&#39;, &#39;Major Fourteenth&#39;),
    (24, &#39;P15&#39;, &#39;Perfect Double-octave&#39;),
    (25, &#39;A15&#39;, &#39;Minor Sixteenth&#39;),
    (26, &#39;M16&#39;, &#39;Major Sixteenth&#39;),
    (27, &#39;m17&#39;, &#39;Minor Seventeenth&#39;),
    (28, &#39;M17&#39;, &#39;Major Seventeenth&#39;),
    (29, &#39;P18&#39;, &#39;Perfect Eighteenth&#39;),
    (30, &#39;A18&#39;, &#39;Augmented Eighteenth&#39;),
    (31, &#39;P19&#39;, &#39;Perfect Nineteenth&#39;),
    (32, &#39;m20&#39;, &#39;Minor Twentieth&#39;),
    (33, &#39;M20&#39;, &#39;Major Twentieth&#39;),
    (34, &#39;m21&#39;, &#39;Minor Twenty-first&#39;),
    (35, &#39;M21&#39;, &#39;Major Twenty-first&#39;),
    (36, &#39;P22&#39;, &#39;Perfect Triple-octave&#39;)
)

CHROMATIC_TYPE = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12)
DIATONIC_MODES = {
    &#39;major&#39;: (0, 2, 4, 5, 7, 9, 11, 12),
    &#39;minor&#39;: (0, 2, 3, 5, 7, 8, 10, 12),
}

# MAJOR keyboard keys (with chromatics)
# keyindex for major and chromatic major context
#  s d   g h j        IIb  IIIb       Vb VIb  VIIb
# z x c v b n m  &lt;-  I   II   III  IV   V   VI   VII
#
#  -- SHIFT meaning an octave higher

# MINOR keyboard keys (with chromatics)
# keyindex for minor and chromatic minor context
#
#  s   f g   j k   eg.:      a#   c# d#    f# g#
# z x c v b n m    -------  a  b c  d  e  f  g

# FIXME: these should be inverted/reverted for descending scales:
KEYBOARD_INDICES = {
    &#39;diatonic&#39;: {
        &#39;minor&#39;: &#39;z xc v bn m Z XC V BN M&#39;,
        &#39;major&#39;: &#39;z x cv b n mZ X CV B NM&#39;
    },
    &#39;chromatic&#39;: {
        &#39;minor&#39;: &quot;zsxcfvgbnjmkZSXCFVGBNJMK&quot;,
        &#39;major&#39;: &quot;zsxdcvgbhnjmZSXDCVGBHNJM&quot;,
    }
}

# how many steps to resolve on tonic,
# after which resolves on tonic octave
# (begins on 0 as it is an index)
# 5 is tritone; then
# [0 1 2 3 4 5] resolves below (tonic)
# and [6 7 8 9 10 11] resolves above (octave)

MAX_SEMITONES_RESOLVE_BELOW = 5

# http://code.activestate.com/recipes/134892/
class _Getch:
    &quot;&quot;&quot;Gets a single character from standard input.  Does not echo to the
screen.&quot;&quot;&quot;

    def __init__(self):
        try:
            self.impl = _GetchWindows()
        except ImportError:
            self.impl = _GetchUnix()

    def __call__(self): return self.impl()


class _GetchUnix:
    def __init__(self):
        import tty
        import sys

    def __call__(self):
        import sys
        import tty
        import termios
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        try:
            tty.setraw(sys.stdin.fileno())
            ch = sys.stdin.read(1)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        return ch


class _GetchWindows:
    def __init__(self):
        import msvcrt

    def __call__(self):
        import msvcrt
        return msvcrt.getch()

# this is for debugging


<div class="viewcode-block" id="print_stuff"><a class="viewcode-back" href="../index.html#birdears.print_stuff">[docs]</a>def print_stuff(question):
    padd = &quot;─&quot; * 30  # vim: insert mode, ^vu2500
    print(&quot;&quot;&quot;
{}

Tonic: {} | Note(Int): {} |  Interval: {} | Semitones(Int): {} |
Is Note Chromatic: {} |
Scale: {}, Octave: {}
Resolution: {},
Chromatic: {}
Concrete Scale: {} | Chroma Concrete: {}
{}
&quot;&quot;&quot;.format(
        padd,
        question.concrete_tonic,
        question.interval[&#39;note_and_octave&#39;],
        &quot;─&quot;.join(INTERVALS[question.interval[&#39;semitones&#39;]][1:]),
        question.interval[&#39;semitones&#39;],
        question.interval[&#39;is_chromatic&#39;],
        &quot;─&quot;.join(question.scales[&#39;diatonic&#39;].scale),
        &quot;{}-{}&quot;.format(question.octave, question.octave + 1),
        &quot;─&quot;.join(question.resolution_pitch),
        &quot;─&quot;.join(question.scales[&#39;chromatic&#39;].scale),
        &quot;─&quot;.join(question.scales[&#39;diatonic_pitch&#39;].scale),
        &quot;─&quot;.join(question.scales[&#39;chromatic_pitch&#39;].scale),
        padd,
    ))</div>

<div class="viewcode-block" id="print_stuff_dictation"><a class="viewcode-back" href="../index.html#birdears.print_stuff_dictation">[docs]</a>def print_stuff_dictation(question):
    padd = &quot;─&quot; * 30  # vim: insert mode, ^vu2500
    print(&quot;&quot;&quot;
{}

Tonic: {} | Note(Int): {} |  Interval: {} | Semitones(Int): {} |
Scale: {}, Octave: {}
Chromatic: {}
Concrete Scale: {} | Chroma Concrete: {}
{}
&quot;&quot;&quot;.format(
        padd,
        question.concrete_tonic,
        &quot;─&quot;.join(map(str, question.question_phrase)),
        &quot;─&quot;.join([INTERVALS[n][1] for n in question.question_phrase]),
        &quot;─&quot;.join([str(n) for n in question.question_phrase]),
        &quot;─&quot;.join(question.scales[&#39;diatonic&#39;].scale),
        &quot;{}-{}&quot;.format(question.octave, question.octave + 1),
        &quot;─&quot;.join(question.scales[&#39;chromatic&#39;].scale),
        &quot;─&quot;.join(question.scales[&#39;diatonic_pitch&#39;].scale),
        &quot;─&quot;.join(question.scales[&#39;chromatic_pitch&#39;].scale),
        padd,
    ))</div>

dictate_notes = 4


<div class="viewcode-block" id="main"><a class="viewcode-back" href="../index.html#birdears.main">[docs]</a>def main():
    from .questions.melodicdictation import MelodicDictationQuestion
    getch = _Getch()

    new_question_bit = True

    while True:
        if new_question_bit is True:

            new_question_bit = False

            input_keys = []
            # question = MelodicDictateQuestion(mode=&#39;major&#39;,descending=True)
            question = MelodicDictationQuestion(mode=&#39;major&#39;)
            # question = HarmonicIntervalQuestion(mode=&#39;major&#39;)
            # question = HarmonicIntervalQuestion(mode=&#39;major&#39;)

            # debug
            if DEBUG:
                print_stuff_dictation(question)

            question.play_question()

        user_input = getch()

        # any response input interval from valid keys
        if user_input in question.keyboard_index and user_input != &#39; &#39;:  # spc

            input_keys.append(user_input)
            print(user_input, end=&#39;&#39;)

            if len(input_keys) == dictate_notes:
                # response = question.check_question(user_input)
                response = question.check_question(input_keys)

                if response[&#39;is_correct&#39;]:
                    # print(&quot;Correct!.. it is “{}”&quot;.\
                    # format( response[&#39;user_interval&#39;]))
                    print(&quot;Correct! It was semitones {}&quot;.
                          format(&quot;-&quot;.join(map(str, question.question_phrase))))
                else:
                    print(&quot;It is incorrect...&quot;)
                    print(&quot;You replied semitones {} but the correct is &quot;
                          &quot;semitones {}&quot;.format(response[&#39;user_semitones&#39;],
                                                question.question_phrase))

                question.play_resolution()

                new_question_bit = True
            # else:
            #    input_keys.append(user_input)
            #    print(user_input,)

        # q - quit
        elif user_input == &#39;q&#39;:
            exit(0)

        # r - repeat interval
        elif user_input == &#39;r&#39;:
            question.play_question()</div>

# wait_keys = 1
# def main():
#     from .harmonicintervalquestion import HarmonicIntervalQuestion
#     from .melodicintervalquestion import MelodicIntervalQuestion
#     getch = _Getch()
#
#     new_question_bit = True
#
#     while True:
#         if new_question_bit is True:
#
#             new_question_bit = False
#
#             input_keys = []
#             #question = HarmonicIntervalQuestion(mode=&#39;major&#39;)
#             question = MelodicIntervalQuestion(mode=&#39;major&#39;,descending=True)
#
#             # debug
#             if DEBUG:
#                 print_stuff(question)
#
#             question.play_question()
#
#         user_input = getch()
#
#         if user_input in question.keyboard_index:
#             response = question.check_question(user_input)
#
#             if response[&#39;is_correct&#39;]:
#                 print(&quot;Correct!.. it is “{}”&quot;.\
#                 format( response[&#39;user_interval&#39;]))
#             else:
#                 print(&quot;It is incorrect... correct is {}.. you said {}&quot;.format(question.interval[&#39;data&#39;],response[&#39;user_interval&#39;]))
#
#             question.play_resolution()
#
#             new_question_bit = True
#
#         # q - quit
#         elif user_input == &#39;q&#39;:
#             exit(0)
#
#         # r - repeat interval
#         elif user_input == &#39;r&#39;:
#             question.play_question()
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Iacchus Mercurius.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>